#unpacking
"""
Пример использования Unpacking в Python.

Unpacking позволяет присваивать значения из кортежей, списков и других итерируемых объектов переменным напрямую.
"""

# Пример обычного Unpacking
# Создание кортежа с тремя элементами
tuple_data = (1, 'apple', 3.14)

# Распаковка кортежа в три отдельные переменные
number, fruit, pi = tuple_data

# Вывод значений переменных
print(f"Number: {number}, Fruit: {fruit}, Pi: {pi}")
# Number: 1, Fruit: apple, Pi: 3.14

# Расширенный Unpacking с использованием звездочки (*)
# Создание списка с несколькими элементами
list_data = [1, 2, 3, 4, 5]

# Распаковка первых двух элементов в отдельные переменные, остальные - в список rest
first, second, *rest = list_data

# Вывод значений переменных
print(f"First: {first}, Second: {second}, Rest: {rest}")
# First: 1, Second: 2, Rest: [3, 4, 5]

# Пример использования * для распаковки средней части списка
*start, last = list_data

# Вывод значений переменных
print(f"Start: {start}, Last: {last}")
# Start: [1, 2, 3, 4], Last: 5

"""
Объяснение кода:

1. В первом блоке демонстрируется обычный Unpacking. 
Кортеж 'tuple_data' распаковывается в три переменные 'number', 'fruit', и 'pi'.

2. Во втором блоке используется расширенный Unpacking с * для списка 'list_data'. 
Первые два элемента распаковываются в переменные 'first' и 'second', 
а оставшиеся элементы - в список 'rest'.

3. В третьем блоке показан другой вариант расширенного Unpacking, 
где * используется для распаковки начальной части списка 'list_data' в список 'start', 
а последний элемент - в переменную 'last'.

В этом блоке кода демонстрируются различные способы использования unpacking в Python. 
Обычный unpacking и расширенный unpacking 
с * обеспечивают гибкость при работе с итерируемыми объектами. 
Комментарии и документация в коде 
помогают понять логику работы этих механизмов и 
способы их применения в различных ситуациях.

Этот подход может быть полезен во многих сценариях, 
особенно когда нужно извлечь из коллекции 
определенные элементы или когда структура данных может варьироваться. 
Использование расширенного unpacking 
позволяет легко адаптироваться к изменяющемуся количеству элементов 
в итерируемых объектах.

"""


'''
Распаковка словаря в аргументы с ключевыми словами 
в Python позволяет использовать ключи словаря как имена параметров функции 
и значения этих ключей как соответствующие аргументы. 
Это делается с помощью оператора **, 
который "распаковывает" словарь в аргументы функции. 
Вот пример с подробными комментариями:
'''

"""
Пример распаковки словаря в аргументы с ключевыми словами.
"""

def greet(name, greeting):
    """
    Простая функция приветствия.

    :param name: Имя человека.
    :param greeting: Приветственное сообщение.
    """
    return f"{greeting}, {name}!"

# Создаем словарь с параметрами для функции
params = {
    "name": "Alice",
    "greeting": "Hello"
}

# Используем распаковку словаря для передачи параметров в функцию
message = greet(**params)

# Вывод результата
print(message)  # Выведет: Hello, Alice!

"""
Объяснение кода:
1. Определена функция 'greet', 
которая принимает два аргумента: 'name' и 'greeting'.
2. Создан словарь 'params', 
ключи которого совпадают с именами параметров функции 'greet'.
3. При вызове 'greet(**params)' 
происходит распаковка словаря: 
ключи словаря используются как имена аргументов функции, 
а их значения - как значения этих аргументов.

В этом примере

функция greet определена для принятия двух параметров: 
name и greeting. 
Затем создается словарь params, 
который содержит соответствующие значения для этих параметров. 
При вызове greet(**params), словарь params "распаковывается", 
и его ключи и значения передаются в функцию как аргументы с ключевыми словами.

Эта техника распаковки особенно полезна, 
когда у вас есть функции с большим количеством параметров 
или когда параметры функции часто изменяются. 
Она позволяет легко адаптировать код, добавляя, 
удаляя или изменяя параметры без необходимости изменять каждый вызов функции.


"""


'''

Распаковка списка в позиционные аргументы в Python 
позволяет передавать элементы списка в функцию как отдельные позиционные аргументы. 
Это делается с помощью оператора *, 
который "распаковывает" элементы списка. 
Давайте рассмотрим пример:

'''
"""
Пример распаковки списка в позиционные аргументы.
"""

def multiply(a, b, c):
    """
    Умножает три числа.

    :param a: Первый множитель.
    :param b: Второй множитель.
    :param c: Третий множитель.
    :return: Произведение a, b и c.
    """
    return a * b * c

# Создаем список с числами
numbers = [2, 3, 4]

# Используем распаковку списка для передачи чисел в функцию
result = multiply(*numbers)

# Вывод результата
print(f"The result is: {result}")
# Выведет: The result is: 24

"""
Объяснение кода:
1. Определена функция 'multiply', 
которая принимает три аргумента и возвращает их произведение.
2. Создан список 'numbers' с тремя элементами.
3. При вызове 'multiply(*numbers)' 
элементы списка 'numbers' передаются в функцию как отдельные позиционные аргументы.

В этом примере используется функция multiply, которая умножает три числа. 
Создается список numbers, содержащий три числа. 
При вызове функции multiply(*numbers) список numbers распаковывается, 
и его элементы передаются в функцию как отдельные позиционные аргументы a, b и c.

Этот метод распаковки очень удобен, 
когда у вас есть итерируемый объект 
(например, список или кортеж), 
и вы хотите передать его элементы в функцию как отдельные аргументы.

"""



"""
Пример распаковки списка в позиционные аргументы для поиска минимального и максимального элементов.
"""

def find_min_max(*args):
    """
    Возвращает минимальное и максимальное значения из переданных аргументов.

    :param args: Произвольное количество числовых аргументов.
    :return: Кортеж из минимального и максимального значения.
    """
    return min(args), max(args)

# Создаем список чисел
numbers = [15, 4, 42, 8, 23]

# Используем распаковку списка для передачи чисел в функцию
min_number, max_number = find_min_max(*numbers)

# Вывод результатов
print(f"Minimum: {min_number}, Maximum: {max_number}")
# Выведет: Minimum: 4, Maximum: 42

"""
Объяснение кода:
1. Функция 'find_min_max' принимает произвольное количество аргументов (чисел) с помощью *args.
2. Внутри функции используются встроенные функции 'min' и 'max' для нахождения минимального и максимального значений из args.
3. Создается список 'numbers' с произвольными числами.
4. При вызове функции 'find_min_max(*numbers)', элементы списка 'numbers' передаются в функцию как отдельные аргументы.


В этом примере функция find_min_max 
принимает произвольное количество числовых аргументов 
и возвращает минимальное и максимальное значения из этих аргументов. 
При вызове функции список numbers распаковывается, 
и его элементы передаются в функцию. 
Таким образом, мы можем легко и гибко находить минимальное и максимальное значения из любого набора чисел.

"""

'''

Давайте рассмотрим более продвинутый и 
интересный пример использования распаковки списков в Python. 
В этом примере мы создадим функцию, 
которая будет форматировать строку адреса, 
используя распаковку списка. 
Эта функция сможет принимать список строк, 
который представляет собой части адреса 
(например, улица, город, страна), 
и возвращать их в форматированном виде.

Пример: Форматирование Адреса

'''

"""
Расширенный пример распаковки списка в позиционные аргументы.

Этот скрипт демонстрирует, как можно использовать распаковку списка для форматирования
адреса из различных компонентов, переданных в функцию как отдельные аргументы.
"""

def format_address(*args):
    """
    Форматирует и возвращает строку адреса из произвольного количества аргументов.

    Параметры:
    *args (str): произвольное количество строк, представляющих части адреса.

    Возвращает:
    str: Строка, представляющая сформированный адрес.
    """
    # Объединение всех аргументов в одну строку с разделителем ', '
    return ', '.join(arg for arg in args if arg)

# Пример использования функции format_address

# Создаем список, содержащий различные компоненты адреса
address_parts = ["221B Baker Street", "London", "NW1", "England"]

# Используем распаковку списка для передачи частей адреса в функцию
formatted_address = format_address(*address_parts)

# Вывод сформатированного адреса
print(f"Formatted Address: {formatted_address}")
# Ожидаемый вывод: Formatted Address: 221B Baker Street, London, NW1, England

"""
Объяснение кода:
1. Определена функция format_address, которая принимает неопределенное количество строковых аргументов (части адреса).
2. Внутри функции используется генератор списка для создания строки, содержащей все переданные аргументы, разделенные запятой и пробелом.
3. В генераторе списка присутствует условие 'if arg', чтобы исключить пустые строки из результата.
4. Функция вызывается с распакованными элементами списка address_parts.
5. Полученная строка выводится на экран.
"""



"""
Демонстрация распаковки списка словарей в переменные и передачи их в функцию в качестве именованных аргументов.
"""

# Определение функции, которая принимает два аргумента
def process_data(arg1, arg2):
    """
    Функция для обработки данных.

    :param arg1: Первый аргумент функции.
    :param arg2: Второй аргумент функции.
    :return: None
    """
    print(f"Arg1: {arg1}, Arg2: {arg2}")

# Создание списка из трех словарей
dict_list = [
    {"arg1": "Data1_1", "arg2": "Data1_2"},
    {"arg1": "Data2_1", "arg2": "Data2_2"},
    {"arg1": "Data3_1", "arg2": "Data3_2"}
]

# Распаковка списка в три отдельные переменные, содержащие словари
dict1, dict2, dict3 = dict_list

# Вызов функции process_data трижды с распаковкой каждого словаря в именованные аргументы
process_data(**dict1) # Выведет: Arg1: Data1_1, Arg2: Data1_2
process_data(**dict2) # Выведет: Arg1: Data2_1, Arg2: Data2_2
process_data(**dict3) # Выведет: Arg1: Data3_1, Arg2: Data3_2

"""
В этом коде:
1. Определена функция 'process_data', принимающая два аргумента.
2. Создан список 'dict_list', содержащий три словаря.
3. Список распаковывается в три переменные 'dict1', 'dict2', 'dict3'.
4. Функция 'process_data' вызывается трижды, каждый раз с распаковкой одного из словарей в именованные аргументы.
"""
